<!DOCTYPE html>
<html>
<head>
	<title>SuperExclusive BDDD precum </title>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.5.16/p5.min.js'></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.5.16/addons/p5.dom.min.js'></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.4/lodash.min.js'></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@800&display=swap" rel="stylesheet">

    <meta name="viewport" content="width=device-width, height=device-height,  initial-scale=1.0, user-scalable=no;user-scalable=0;"/>
</head>


<style>

    body{
        background-color: black;
        color: red;
        overflow: hidden;
    }
    .container{
        display: flex;
        flex-direction: column;        
        position: fixed;
        margin: 100px;
        position: fixed;
        top: 0;
        bottom: 0;
        left:0;
        right: 0;
        border-radius: 40px;
        padding: 30px;
        align-items: center;
        

        border: 2px orange solid;
        -webkit-box-shadow: inset 0 0 0.75em 0.25em red,
            0 0 0.75em 0.25em red;
        -moz-box-shadow: inset 0 0 0.75em 0.25em red,
            0 0 0.75em 0.25em red;

        box-shadow: inset 0 0 0.75em 0.25em red,
            0 0 0.75em 0.25em red;
            
    }
    #data{
        
        width: 100%;
        text-align: center;
        color: red;
        background-color: transparent;
        resize: none;
        outline: none;
        border-color: red;
        min-height: 300px;
        
        -webkit-box-shadow: -2px -1px 15px 7px rgba(255,0,0,0.5);
  -moz-box-shadow: -3px -2px 30px 14px rgba(255,0,0,0.425);
  box-shadow: -4px -3px 45px 21px rgba(255,0,0,0.35);
    
    }
    #data:focus{
        border: 0px 0px 0px 5px;
    }

    #submit{
        background-color: red;
        color: #ffffff;
        width: 100%;

        font-family: 'Open Sans', bold;
        min-height: 150px;
        border-radius: 40px;
        border-color: red;
        font-size: 50px;
        margin-top: 100px;


        -webkit-box-shadow: inset 0 0 0.75em 0.25em red,
            0 0 0.75em 0.25em red;
        -moz-box-shadow: inset 0 0 0.75em 0.25em red,
            0 0 0.75em 0.25em red;

        box-shadow: inset 0 0 0.75em 0.25em red,
            0 0 0.75em 0.25em red;



    }

    #submit_container{
        position: fixed;

        right: 0;
        left: 0;
        bottom: 0;
        padding: 150px;
    }

    #myCanvas{
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
    }
    #menuContainer{
        display: none;
    }

    @media only screen and (max-width: 600px){
        
        /* #submit{
            background-color: blue;
            color: white;
            min-width: 300px;
            width: 90%;
            min-height: 50px;
            border-radius: 40px;
            border-color: red;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);

        } */

    }
    
    .dot{
        width: 15px;
        height: 15px;
        background-color: red;
        border-radius: 50%;
        position: fixed;
        border: 2px orange solid;
        -webkit-box-shadow: inset 0 0 0.75em 0.25em red,
            0 0 0.75em 0.25em red;
        -moz-box-shadow: inset 0 0 0.75em 0.25em red,
            0 0 0.75em 0.25em red;

        box-shadow: inset 0 0 0.75em 0.25em red,
            0 0 0.75em 0.25em red;
    }
    .top{
        top: 50px;
        left: 50%;
    }
    .bottom{
        bottom: 50px;
        left: 50%;
    }
    .left{
        top: 50%;
        left: 50px;
    }
    .right{
        top: 50%;
        right: 50px;
    }
    
</style>
<body>

    <div class="dot top"></div>
    <div class="dot left"></div>
    <div class="dot right"></div>
    
    <div class="container">
        <div id="submit_container">
        <textarea id="data"></textarea>

        <button id="submit">SUBMIT</button>

        </div>
    </div>
 

    <script src='/animation.js'></script>



    <script type="module">
        import { io } from "https://cdn.socket.io/4.4.1/socket.io.esm.min.js";
      
        const daddy_replies = ["give me more data... ", "you like that don't you, little slut", "good data...", "fuck yeah..."]
        const sio = io();

        const o = document.getElementById('output');

		function log(line) {
			o.innerHTML += line + "\n";
			console.log(line);
		}

        function submit(){
            let text = document.getElementById("data").value;
            if(text == null  || text == ""){
                text = "no data makes big data dom daddy a dull boy";
            }
            sio.emit("hello", text);


            document.getElementById("data").value = daddy_replies[Math.floor(Math.random() * daddy_replies.length)];
            console.log("submit button press");

        }

        const roomName = "bddd_dungeon";

        document.getElementById("submit").addEventListener('click', submit);
		
		window.onload = function () {
			// console.log("Starting test...");

            // sio.emit("hello", "from onloadfucntion")
			
			sio.on('connect', () => {
				sio.emit('KnockKnock');
			});
			
			// sio.on('WhosThere', () => {
			// 	log('RECEIVED a WhosThere event without payload data just as expected.');
			// 	sio.emit('ItsMe', {
			// 		version: 'FakeVersion'
			// 	});
			// });
			
			// sio.on('Welcome', (payload) => {
			// 	log('SERVER: ' + payload);
			// });
			
			// sio.on('TechData', (srv) => {
			// 	log("Received the POD name from the server. Upadting UI. Oh! It's " + srv.timestamp + " by the way."); //we do not acually update ui in the test app
			// });
			
			// sio.on('disconnect', () => {
			// 	log('Disconnected from server.'); //we do not acually update ui in the test app
			// 	sio.close();
			// });
		}






        let users = document.getElementsByClassName("user");
let sentences = ["submit your data", "fuck yeah", "little slut", "give me what i want", "make daddy proud", "submit", "submit", "submit to me", "you deserve to get fucked"]

const s = (p) => {  
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    let FONT_SIZE = 30;
    const charList = (charCode, n) => String.fromCharCode(..._.range(charCode, charCode + n));
    const unicodeA = 65;
    const unicode0 = 48;
    const unicodeKa = 65398;
    const alphabet = charList(unicodeA, 26); 
    const numbers = charList(unicode0, 10);
    const katakana = charList(unicodeKa, 32);
    const SYMBOLS = ['*', '+', '<', '>', ...katakana, "data", "bitch", "submit", "bddd"];
    let m, control;
    
    p.setup = () => {
      p.frameRate(60);    
      const canvas = p.createCanvas(p.windowWidth, p.windowHeight);
 

      canvas.id("mycanvas");
      p.colorMode(p.HSB, 360, 100, 100, 100);  
      p.textFont("monospace", FONT_SIZE);
      p.textAlign(p.LEFT, p.TOP);
  
      m = new Matrix();
      control = new Control();
      m.run();
      

      shuffle(sentences);
    }
    
    p.windowResized = () => {
      FONT_SIZE = isMobile ? 15 : 30;
      p.textFont("monospace", FONT_SIZE);
      
      let width, height; 
      if (m.isFullscreen) {      
        if (isMobile && window.matchMedia("(orientation: landscape)").matches) {
          width = p.displayHeight;
          height = p.displayWidth; 
        } else {
          width = p.displayWidth; 
          height = p.displayHeight;
        }
      } else {
        width = p.windowWidth;
        height = p.windowHeight;
      }
      p.resizeCanvas(width, height);
  
      m = new Matrix({ isFullscreen: m.isFullscreen });
      m.run();
    }
    
    class Control {
      constructor() {
        this.menuContainer = p.createDiv('');
        this.menuContainer.id('menuContainer');
  
        this.menu = p.createDiv('');
        this.menu.id('menu');
        this.menu.parent(this.menuContainer);
        
        this.rain = this.createButton('Rain', Control.RAIN);
        this.screensaver = this.createButton('Words', Control.WORDS);
        this.movie = this.createButton('Movie', Control.MOVIE);
        this.benchmark = this.createButton('Benchmark', Control.BENCHMARK);
        
        this.menuToggle = this.createCheckbox('Control', false, 'menuToggle', Control.MENU_TOGGLE);
        this.playToggle = this.createCheckbox('Play', m.isAnimating, 'playToggle', Control.PLAY_TOGGLE);
        this.infoToggle = this.createCheckbox('Info', m.db.isEnabled, 'infoToggle',  Control.INFO_TOGGLE, 'link');
        this.fullscreenToggle = this.createCheckbox('Full screen', false, 'fullscreenToggle',  Control.FULLSCREEN_TOGGLE, 'link');
        this.infoToggle.parent(this.menu);
        this.fullscreenToggle.parent(this.menu);
        
        
        this.createLabelUpdater(this.playToggle, () => m.isAnimating ? '❚❚' : '►', 'isAnimating');
        this.createLabelUpdater(this.infoToggle, () => m.db.isEnabled ? 'Hide info' : 'Show info', 'showInfo');
        this.createLabelUpdater(this.fullscreenToggle, () => p.fullscreen() ? 'Exit fullscreen' : 'Enter fullscreen', 'fullscreen');
        
        this.handleControl(Control.MENU_TOGGLE);
      }
      
      createLabelUpdater(toggle, label, event) {
        const labelUpdate = (toggle, label) => {
          return () => {
            const checkboxLabel = toggle.elt.querySelector('label');
            checkboxLabel.textContent = label();
          }
        };
        
        const labeler = labelUpdate(toggle, label);
        document.addEventListener(event, labeler);
        labeler();
      }
      
      createButton(label, trigger) {
        const btn = p.createButton(label);
        btn.mouseClicked(this.handleControl.bind(this, trigger));
        btn.class('controls');
        btn.parent(this.menu);
        return btn;
      }
      
      createCheckbox(label, defaultVal, id, trigger, className) {
        const checkbox = p.createCheckbox(label, defaultVal);
        checkbox.id(id);
        checkbox.class(`toggle ${className}`);
        checkbox.changed(this.handleControl.bind(this, trigger));
        checkbox.parent(this.menuContainer);
        return checkbox;
      }
      
      handleControl(trigger) {
        if (trigger === Control.RAIN) {
          m = new Matrix();
          m.scenes = [new Rain({ cloud: m.cloud })];  
          m.run();
        } else if (trigger === Control.WORDS) {
          m = new Matrix();
          m.scenes = [new Words({ cloud: m.cloud })];  
          m.run();
        } else if (trigger === Control.MOVIE) {
          m = new Matrix();
          m.scenes = [new Rain({ cloud: m.cloud, time: 300 }), new Title({ cloud: m.cloud })];
          m.run();
        } else if (trigger === Control.MENU_TOGGLE) {
          if (this.menuToggle.checked()) {
            this.menu.show();
          } else {
            this.menu.hide();
          }  
        } else if (trigger === Control.PLAY_TOGGLE) {
          m.isAnimating = !m.isAnimating;
        } else if (trigger === Control.BENCHMARK) {
          m.bench.reset();
        } else if (trigger === Control.INFO_TOGGLE) {
          m.db.isEnabled = !m.db.isEnabled;
        } else if (trigger === Control.FULLSCREEN_TOGGLE) {
          m.isFullscreen = !m.isFullscreen;
        }
      }
    }
    
    Control.RAIN = 'rain';
    Control.WORDS = 'words';
    Control.MOVIE = 'movie';
    Control.MENU_TOGGLE = 'menu toggle';
    Control.BENCHMARK = 'benchmark';
    Control.INFO_TOGGLE = 'info toggle';
    Control.FULLSCREEN_TOGGLE = 'fullscreen toggle';
    
    
    class Symbol {
      constructor({ x, y, symbol, died }) {
        this.pos = p.createVector(x, y);
        this.color = p.color(360, 100, 100);
        this.life = 100;
        this.symbol = symbol || _.sample(SYMBOLS);
        this.died = died || (() => {});
      }
  
      update(newColor) {
        if (newColor) {
          this.color = newColor;
        } else {
          if (this.life <= 0) {
            this.died(this);
            return;
          } else if (this.life > 50) {
            this.life -= 0.5;
          } else {
            this.life -= 1;
          }
  
          if (this.life % 2 === 0 && _.random(true) > 0.9) {
            this.symbol = _.sample(SYMBOLS);    
          } 
          this.color = p.color(5, 100, this.life);
        }
      }
  
      display() {
        p.fill(this.color);
        p.text(this.symbol, this.pos.x, this.pos.y);   
      }
    }
    
    class Raindrop {
      constructor({x, y, died, stopped, color, middleLetter}) {
        this.pos = p.createVector(x, y);        
        this.symbols = new Map();    
        this.addSymbol({ x, y });
        this.died = died || (() => {});
        this.middleLetter = middleLetter;
        this.stopped = stopped || (() => {});
        this.color = color;
        this.symbolCount = 0;
      }
  
      addSymbol({x, y, symbol }) {
        const s = new Symbol({ x, y, symbol, died: this.removeSymbol.bind(this) });
        this.lowestSymbol = s;
        this.symbols.set(s, s);
        this.symbolCount += 1;
      }
  
      update() {
        this.pos.add(p.createVector(0, 4));   
  
        const nextSymbolY = this.symbolCount * FONT_SIZE;
        const middle = p.height /2;
        const { x, y } = this.pos;
        if (this.middleLetter) {
          if (y < middle && y > nextSymbolY) {
            this.addSymbol({ x, y: nextSymbolY });
          } else if (nextSymbolY >= middle && nextSymbolY < middle + FONT_SIZE) {
            this.addSymbol({ x, y: nextSymbolY, symbol: this.middleLetter });
            this.stopped();
          } else if (y > middle) {
            this.pos.y = middle;
          }
        } else if (y < p.height + FONT_SIZE && y > nextSymbolY) {
          this.addSymbol({ x, y: nextSymbolY });
        } else if (y > p.height && this.symbols.size === 1) {
          this.died();
        }
      }
  
      display() {
        this.symbols.forEach((symbol, i) => {
          const lowestSymbol = symbol === this.lowestSymbol;
          const lowestSymbolColor = this.color || p.color(4, 0, 100);
  
          symbol.update(lowestSymbol && lowestSymbolColor);
          symbol.display();
        });
      }
  
      removeSymbol(key) {
        this.symbols.delete(key);
      }
    }
    
    class Cloud {
      constructor(color) {
        this.raindrops = new Map();    
        this.newRaindropTime = 0;
        this.curText = [];
        this.textColor = color;
        this.curTextOrder = []; // text falling from middle
        this.textOrder = []; // text falling into middle
      }
      
      static get size() {
          return p.floor(p.width / FONT_SIZE);
      }
  
      setText(text, time, done) {  
        this.text = text;
        this.textTime = time;
        this.textTimeDone = done || _.noop;
        this.textOrder = this.order(text);
        this.getMiddleLetter = _.zipObject(this.textOrder, this.text.split(''));
  
        let range;
        if (this.textOrder.length > this.curTextOrder.length) {
          range = this.getTextCols(this.textOrder.length);
        } else {
          range = this.getTextCols(this.curTextOrder.length);
        }
        const beforeText = _.range(0, range.start);
        const afterText = _.range(range.end, Cloud.size);
        this.outsideTextCols = beforeText.concat(afterText);
      };
  
      order(text) {
        const range = this.getTextCols(text.length);
        return _.range(range.start, range.start + text.length);
      };
  
      getTextCols(textLength) {
        if (!textLength) { return; }
        const start = p.floor((Cloud.size - textLength) / 2);
        return {
          start: start,
          end: start + textLength,
        };
      }
  
      addRaindrop(col) {
        if (!this.raindrops.get(col)) {
          this.raindrops.set(col, new Raindrop({ 
            x: FONT_SIZE * col, 
            y: 0, 
            died: this.removeRaindrop.bind(this, col), 
            stopped: this.stoppedRaindrop.bind(this, col),
            color: this.textColor,
            middleLetter: _.get(this, ['getMiddleLetter', col]),
          }));
          return true;
        }
      }
  
      textTimer() {
        const curText = this.curText.join('');
        if (this.text && this.text === curText && this.textTime >= 0) {
          if (this.textTime === 0) {
            this.curTextOrder = this.order(this.text);
            this.textTimeDone();    
          }
          this.textTime--;
        }
      }
  
      update() {
        this.textTimer();   
        
        if (p.millis() > this.newRaindropTime) {
          if (this.raindrops.size < Cloud.size) {
            const prob = { textOut: 0.4, textIn: 0.7 };            
            const rand = _.random(true);
            
            if (this.curTextOrder.length === 0 && this.textOrder.length > 0) {
              prob.textOut = 0;
              prob.textIn = 0.5;
            } else if (this.curTextOrder.length === 0 && this.textOrder.length === 0) {
              prob.textOut = 0;
              prob.textIn = 0;
            }
  
            if (rand < prob.textOut) {
              if (this.curTextOrder.length > 0) {
                const index = _.random(this.curTextOrder.length - 1);
                const col = this.curTextOrder.splice(index, 1)[0];              
                if (!this.textOrder.includes(col)) {
                  this.outsideTextCols.push(col);
                }
  
                this.raindrops.get(col).middleLetter = '';
                this.curText[col] = null;
              }
            } else if (rand < prob.textIn) {
              if (this.textOrder.length > 0) {
                // add new text only if raindrop doesn't exist
                const index = _.random(this.textOrder.length - 1);
                const col = this.textOrder[index];
                if (this.addRaindrop(col)) {
                  this.textOrder.splice(index, 1);
                }
              }
            } else {
              let col = this.outsideTextCols  
              ? _.sample(this.outsideTextCols) 
              : _.random(Cloud.size - 1);
              this.addRaindrop(col);
            }
          }
          this.newRaindropTime = p.millis() + _.random(50, 100);
        }
      }
  
      display() {
        this.raindrops.forEach(raindrop => {
          raindrop.update();
          raindrop.display();
        });
      }
  
      removeRaindrop(col) {
        this.raindrops.delete(col);        
      }
  
      stoppedRaindrop(col) {
        var middleLetter = this.getMiddleLetter[col];
        this.curText[col] = middleLetter;        
      }
    }
    
    class Scene {
      constructor({cloud, time}) {
        this.cloud = cloud;
        this.time = time;
        this.done = false;
        this.name = '';
      }
  
      get isDone() {
        return this.done;
      }
  
      set isDone(val) {
        this.done = val;
      }
  
      run() {
        this.cloud.update();
        this.cloud.display();
  
        if (Number.isInteger(this.time)) {
          if (this.time > 0) {
            this.time--;
          } else {
            this.isDone = true;
          }
        }
      }
    }
    
    class Words extends Scene {
      constructor({ cloud, time }) {
        super({ cloud, time });
        this.newWord = true;
        this.name = 'Words';
      }
  
     
  
      draw() {
        p.background(0, 0, 0);
        
        if (this.newWord) {
          const quote = getSentence();
          console.log("quote to be written", quote, sentences);
         //set time of sentence on screen (200)
          const maxChars = p.width / FONT_SIZE;
          if (quote.length < maxChars) {
            this.cloud.setText(quote, 200, () => {
              this.cloud.text = "";
              this.newWord = true;    
            });
            this.newWord = false;    
          }
        }
        this.run();
      }
    }
    
    class Rain extends Scene {
      constructor(config) {
        super(config);
        this.name = 'Rain';
      }
  
      draw() {
        p.background(0, 0, 0);
        this.run();
      }
    };
  
    class Title extends Scene {
      constructor(cloud) {
        super(cloud);
        this.scale = 1;
        this.translate = 0;
        this.move = 0;
        this.name = 'Title';
        this.setupOnce = _.once(this.setup);
      }
  
      setup() {
        this.cloud.setText("THE MATRIX", 0, () => this.isDone = true);
      }
  
      draw() {
        this.setupOnce();
        p.background(0, 0, 0);
        p.push();
        p.translate(-this.translate, -this.translate);
        p.scale(this.scale);
        this.run();
  
        // d.drawRects();
  
        this.translate = p.lerp(0, 200, this.move); // width - title.length * fontSize
        this.scale = (p.width + 2 * this.translate) / p.width;
        p.pop();
  
        if (this.move <= 1) {
          this.move += 0.01;
        }
      }
    }
    
    class Benchmark {
      constructor({ cloud }) {
        this.frames = 1000;
        this.sampleRate = 30;
        this.stats = this.clearStats();
        this.state = "IDLE";
        this.cloud = cloud;
      }
  
      clearStats() {
        return {
          fps: { data: [] },
          raindrops: { data: [] },
          symbols: { data: [] },
        };
      }
  
      reset() {
        this.frames = 1000;
        this.stats = this.clearStats();
        this.state = "IDLE";
      }
  
      run() {
        const minMax = (val, stat) => {
          const { min, max } = stat;
  
          if (min === undefined || val < min) {
            stat.min = val;
          }
  
          if (max === undefined || val > max) {
            stat.max = val;
          }
        };
  
        const average = (data) => {
          const sum = data.reduce((sum, val) => sum += val);
          return (sum / data.length).toFixed(2);
        };
  
        this.frames--;
  
        if (this.frames > 0) {
          this.state = "RUNNING";
          if (this.frames % this.sampleRate !== 0) return;
  
          const fps = parseInt(p.frameRate());
          this.stats.fps.data.push(fps);
          minMax(fps, this.stats.fps);
  
          const raindropCount = this.cloud.raindrops.size;
          this.stats.raindrops.data.push(raindropCount);
          minMax(raindropCount, this.stats.raindrops);
  
          let symbolCount = 0;
          this.cloud.raindrops.forEach(raindrop => symbolCount += raindrop.symbols.size); 
          this.stats.symbols.data.push(symbolCount);
          minMax(symbolCount, this.stats.symbols);
        } else if (this.frames === 0) {
          this.state = "DONE";
          this.stats.fps.avg = average(this.stats.fps.data);
          this.stats.raindrops.avg = average(this.stats.raindrops.data);
          this.stats.symbols.avg = average(this.stats.symbols.data);
        }     
      }
    }
    
    class DebugMatrix {
      constructor({ isEnabled, matrix }) {
        this.enabled;  
        this.isEnabled = isEnabled;
        this.infoMsg = "";
        this.textMargin = 5;
        this.fontSize = 15;
        this.font = "sans-serif";
        this.matrix = matrix;
      }
      
      get isEnabled() {
        return this.enabled;
      }
      
      set isEnabled(val) {
        this.enabled = val;
        document.dispatchEvent(new Event('showInfo'));
      }
  
      drawRects() {
        if (!this.isEnabled) return;
  
        p.push();
        p.rectMode(p.CENTER);
        p.stroke(0, 100, 100);
        p.fill(0, 0, 0, 0);
  
        for (var i=0; i<7; i++) {
          p.rect(p.width/2, p.height/2, 50 + i * 50, 50 + i * 50);
        }
        p.pop();             
      }
  

    }
    
    class Matrix {
      constructor({ isFullscreen } = {}) {
        this.isAnimating = false;
        this.isFullscreen = isFullscreen;
        this.cloud = new Cloud();
        this.scenes = [];
        this.sceneNum = 0;
        this.scenes.push(new Words({ cloud: this.cloud }));
        // scenes.push(new Rain({ cloud, time: 300 }));
        // scenes.push(new Title({ cloud }));
        this.bench = new Benchmark({ cloud: this.cloud });
        this.db = new DebugMatrix({ isEnabled: true, matrix: this });  
      }  
      
      get isAnimating() {
        return this.animating;
      }
      
      set isAnimating(val) {
        this.animating = val;
        this.animating ? p.loop() : p.noLoop();
        
        const event = new Event('isAnimating');
        document.dispatchEvent(event);
      }
      
      get isFullscreen() {
        return this.fullscreen;
      }
      
      set isFullscreen(val) {
        this.fullscreen = val;
        p.fullscreen(this.fullscreen);
        document.dispatchEvent(new Event('fullscreen'));
      }
      
      run() {
        this.isAnimating = true;
      }
    }
    
    p.draw = () => {
      const scene = m.scenes[m.sceneNum];
      if (scene) {
        scene.draw();
        if (scene.isDone) {
          m.sceneNum++;    
        } 
      } else {
        p.background(0);
      }
  
      if (m.db.isEnabled) {
        m.bench.run();
      }    
    }; 
  }
  







  const myp5 = new p5(s);
  console.log(myp5);



// let sentences = []




function getSentence(){

//    if(sentences.length > 0){
//        let index = Math.floor(Math.random() * sentences.length);
//        let sentence = sentences[index]
//        sentences.splice(index, 1);
//        return sentence
//    } else {
//        return "submit your data"
//    }
   return ":)"

}

function shuffle(array) {
    var currentIndex = array.length, temporaryValue, randomIndex;
  
    // While there remain elements to shuffle...
    while (0 !== currentIndex) {
  
      // Pick a remaining element...
      randomIndex = Math.floor(Math.random() * currentIndex);
      currentIndex -= 1;
  
      // And swap it with the current element.
      temporaryValue = array[currentIndex];
      array[currentIndex] = array[randomIndex];
      array[randomIndex] = temporaryValue;
    }
  
    return array;
  }





      </script>
</html>